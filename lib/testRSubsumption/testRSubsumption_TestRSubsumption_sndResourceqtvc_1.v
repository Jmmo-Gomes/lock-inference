(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.MinMax.
Require int.ComputerDivision.
Require int.Power.
Require map.Map.
Require list.List.
Require list.Length.
Require list.Mem.
Require set.Fset.
Require list.Nth.
Require option.Option.
Require list.Append.
Require list.Reverse.
Require list.RevAppend.
Require list.NumOcc.

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | ref'mk : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments ref'mk {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | ref'mk x => x
  end.

(* Why3 assumption *)
Definition fst {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (x:(a* b)%type) : a :=
  match x with
  | (r, _) => r
  end.

(* Why3 assumption *)
Definition snd {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (x:(a* b)%type) : b :=
  match x with
  | (_, r) => r
  end.

(* Why3 assumption *)
Inductive result (a:Type)
  (b:Type) :=
  | Ok : a -> result a b
  | Error : b -> result a b.
Axiom result_WhyType : forall (a:Type) {a_WT:WhyType a}
  (b:Type) {b_WT:WhyType b}, WhyType (result a b).
Existing Instance result_WhyType.
Arguments Ok {a} {b}.
Arguments Error {a} {b}.

Parameter same_location: forall {a:Type} {a_WT:WhyType a}, a -> a -> Prop.

Axiom same_location_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a), same_location x y -> (x = y).

Parameter infix_tleq:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom infix_tleq'spec :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((infix_tleq x y) = Init.Datatypes.true) <-> ~ (x = y).

(* Why3 assumption *)
Definition is_pre_order {a:Type} {a_WT:WhyType a}
    (cmp:a -> a -> Numbers.BinNums.Z) : Prop :=
  (forall (x:a), ((cmp x x) = 0%Z)) /\
  (forall (x:a) (y:a), ((cmp x y) = 0%Z) <-> ((cmp y x) = 0%Z)) /\
  (forall (x:a) (y:a), ((cmp x y) < 0%Z)%Z <-> (0%Z < (cmp y x))%Z) /\
  (forall (x:a) (y:a) (z:a),
   (((cmp x y) = 0%Z) -> ((cmp y z) = 0%Z) -> ((cmp x z) = 0%Z)) /\
   (((cmp x y) = 0%Z) -> ((cmp y z) < 0%Z)%Z -> ((cmp x z) < 0%Z)%Z) /\
   (((cmp x y) < 0%Z)%Z -> ((cmp y z) = 0%Z) -> ((cmp x z) < 0%Z)%Z) /\
   (((cmp x y) < 0%Z)%Z -> ((cmp y z) < 0%Z)%Z -> ((cmp x z) < 0%Z)%Z)).

Axiom cmp_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a) (cmp:a -> a -> Numbers.BinNums.Z), is_pre_order cmp ->
  ((cmp x y) = 0%Z) <-> (x = y).

Parameter compare:
  forall {a:Type} {a_WT:WhyType a}, a -> a -> Numbers.BinNums.Z.

Axiom compare_pre_order :
  forall {a:Type} {a_WT:WhyType a},
  is_pre_order (fun (x:a) (y:a) => compare x y).

Axiom seq : forall (a:Type), Type.
Parameter seq_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (seq a).
Existing Instance seq_WhyType.

Parameter length:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z.

Axiom length_nonnegative :
  forall {a:Type} {a_WT:WhyType a}, forall (s:seq a), (0%Z <= (length s))%Z.

Parameter get:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a.

Parameter infix_eqeq:
  forall {a:Type} {a_WT:WhyType a}, seq a -> seq a -> Prop.

Axiom infix_eqeq'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a),
  (infix_eqeq s1 s2 <->
   ((length s1) = (length s2)) /\
   (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length s1))%Z ->
    ((get s1 i) = (get s2 i)))) /\
  (infix_eqeq s1 s2 -> (s1 = s2)).

Parameter create:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z ->
  (Numbers.BinNums.Z -> a) -> seq a.

Axiom create'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (len:Numbers.BinNums.Z) (f:Numbers.BinNums.Z -> a),
  (0%Z <= len)%Z ->
  ((length (create len f)) = len) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < len)%Z ->
   ((get (create len f) i) = (f i))).

Parameter empty: forall {a:Type} {a_WT:WhyType a}, seq a.

Axiom empty'def :
  forall {a:Type} {a_WT:WhyType a}, ((length (empty : seq a)) = 0%Z).

Parameter set:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a -> seq a.

Parameter result1:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a ->
  Numbers.BinNums.Z -> a.

Axiom result'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a) (j:Numbers.BinNums.Z),
  ((j = i) -> ((result1 s i v j) = v)) /\
  (~ (j = i) -> ((result1 s i v j) = (get s j))).

Axiom set'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z ->
  ((set s i v) = (create (length s) (result1 s i v))).

Axiom set'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z ->
  ((length (set s i v)) = (length s)) /\
  ((get (set s i v) i) = v) /\
  (forall (j:Numbers.BinNums.Z),
   ((0%Z <= j)%Z /\ (j < (length s))%Z) /\ ~ (j = i) ->
   ((get (set s i v) j) = (get s j))).

Parameter mixfix_lblsmnrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a -> seq a.

Axiom mixfix_lblsmnrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z ->
  ((mixfix_lblsmnrb s i v) = (set s i v)).

(* Why3 assumption *)
Definition singleton {a:Type} {a_WT:WhyType a} (v:a) : seq a :=
  create 1%Z (fun (us:Numbers.BinNums.Z) => v).

Axiom singleton'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (v:a),
  ((length (singleton v)) = 1%Z) /\ ((get (singleton v) 0%Z) = v).

Parameter result2:
  forall {a:Type} {a_WT:WhyType a}, a -> seq a -> Numbers.BinNums.Z -> a.

Axiom result'def1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a) (i:Numbers.BinNums.Z),
  ((i = 0%Z) -> ((result2 x s i) = x)) /\
  (~ (i = 0%Z) -> ((result2 x s i) = (get s (i - 1%Z)%Z))).

(* Why3 assumption *)
Definition cons {a:Type} {a_WT:WhyType a} (x:a) (s:seq a) : seq a :=
  create (1%Z + (length s))%Z (result2 x s).

Axiom cons'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a),
  ((length (cons x s)) = (1%Z + (length s))%Z) /\
  ((get (cons x s) 0%Z) = x) /\
  (forall (i:Numbers.BinNums.Z), (0%Z < i)%Z /\ (i <= (length s))%Z ->
   ((get (cons x s) i) = (get s (i - 1%Z)%Z))).

Parameter result3:
  forall {a:Type} {a_WT:WhyType a}, seq a -> a -> Numbers.BinNums.Z -> a.

Axiom result'def2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a) (i:Numbers.BinNums.Z),
  ((i = (length s)) -> ((result3 s x i) = x)) /\
  (~ (i = (length s)) -> ((result3 s x i) = (get s i))).

(* Why3 assumption *)
Definition snoc {a:Type} {a_WT:WhyType a} (s:seq a) (x:a) : seq a :=
  create (1%Z + (length s))%Z (result3 s x).

Axiom snoc'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a),
  ((length (snoc s x)) = (1%Z + (length s))%Z) /\
  ((get (snoc s x) (length s)) = x) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length s))%Z ->
   ((get (snoc s x) i) = (get s i))).

Parameter mixfix_lbdtdtrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> seq a.

Axiom mixfix_lbdtdtrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length s))%Z ->
  ((mixfix_lbdtdtrb s i j) =
   (create (j - i)%Z (fun (k:Numbers.BinNums.Z) => get s (i + k)%Z))).

Axiom mixfix_lbdtdtrb'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length s))%Z ->
  ((length (mixfix_lbdtdtrb s i j)) = (j - i)%Z) /\
  (forall (k:Numbers.BinNums.Z), (0%Z <= k)%Z /\ (k < (j - i)%Z)%Z ->
   ((get (mixfix_lbdtdtrb s i j) k) = (get s (i + k)%Z))).

Parameter mixfix_lb_dtdtrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> seq a.

Axiom mixfix_lb_dtdtrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= (length s))%Z ->
  ((mixfix_lb_dtdtrb s i) = (mixfix_lbdtdtrb s i (length s))).

Parameter mixfix_lbdtdt_rb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> seq a.

Axiom mixfix_lbdtdt_rb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (j:Numbers.BinNums.Z),
  (0%Z <= j)%Z /\ (j <= (length s))%Z ->
  ((mixfix_lbdtdt_rb s j) = (mixfix_lbdtdtrb s 0%Z j)).

Parameter result4:
  forall {a:Type} {a_WT:WhyType a}, seq a -> seq a -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> a.

Axiom result'def3 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a) (l:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  ((i < l)%Z -> ((result4 s1 s2 l i) = (get s1 i))) /\
  (~ (i < l)%Z -> ((result4 s1 s2 l i) = (get s2 (i - l)%Z))).

(* Why3 assumption *)
Definition infix_plpl {a:Type} {a_WT:WhyType a} (s1:seq a) (s2:seq a) : seq a :=
  let l := length s1 in create (l + (length s2))%Z (result4 s1 s2 l).

Axiom infix_plpl'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a),
  ((length (infix_plpl s1 s2)) = ((length s1) + (length s2))%Z) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length s1))%Z ->
   ((get (infix_plpl s1 s2) i) = (get s1 i))) /\
  (forall (i:Numbers.BinNums.Z),
   ((length s1) <= i)%Z /\ (i < (length (infix_plpl s1 s2)))%Z ->
   ((get (infix_plpl s1 s2) i) = (get s2 (i - (length s1))%Z))).

Axiom my_array : forall (a:Type), Type.
Parameter my_array_WhyType :
  forall (a:Type) {a_WT:WhyType a}, WhyType (my_array a).
Existing Instance my_array_WhyType.

Parameter elts: forall {a:Type} {a_WT:WhyType a}, my_array a -> seq a.

Parameter length1:
  forall {a:Type} {a_WT:WhyType a}, my_array a -> Numbers.BinNums.Z.

Axiom my_array'invariant :
  forall {a:Type} {a_WT:WhyType a},
  forall (self:my_array a),
  (0%Z <= (length1 self))%Z /\ ((length1 self) = (length (elts self))).

(* Why3 assumption *)
Definition mixfix_lbrb {a:Type} {a_WT:WhyType a} (a1:my_array a)
    (i:Numbers.BinNums.Z) : a :=
  get (elts a1) i.

Parameter to_list_range:
  forall {a:Type} {a_WT:WhyType a}, my_array a -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> Init.Datatypes.list a.

Axiom to_list_range'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:my_array a) (l:Numbers.BinNums.Z) (u:Numbers.BinNums.Z),
  (0%Z <= l)%Z /\ (u <= (length1 a1))%Z ->
  ((u <= l)%Z -> ((to_list_range a1 l u) = Init.Datatypes.nil)) /\
  (~ (u <= l)%Z ->
   ((to_list_range a1 l u) =
    (Init.Datatypes.cons (mixfix_lbrb a1 l) (to_list_range a1 (l + 1%Z)%Z u)))).

Axiom to_list_append :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:my_array a) (l:Numbers.BinNums.Z) (m:Numbers.BinNums.Z)
    (u:Numbers.BinNums.Z),
  (0%Z <= l)%Z /\ (l <= m)%Z /\ (m <= u)%Z /\ (u <= (length1 a1))%Z ->
  ((Init.Datatypes.app (to_list_range a1 l m) (to_list_range a1 m u)) =
   (to_list_range a1 l u)).

(* Why3 assumption *)
Definition mem {a:Type} {a_WT:WhyType a} (x:a) (s:seq a) : Prop :=
  exists i:Numbers.BinNums.Z,
  ((0%Z <= i)%Z /\ (i < (length s))%Z) /\ ((get s i) = x).

Axiom mem_append :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s1:seq a) (s2:seq a),
  mem x (infix_plpl s1 s2) <-> mem x s1 \/ mem x s2.

Axiom mem_tail :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a), (0%Z < (length s))%Z ->
  mem x s <-> (x = (get s 0%Z)) \/ mem x (mixfix_lb_dtdtrb s 1%Z).

(* Why3 assumption *)
Definition mem1 {a:Type} {a_WT:WhyType a} (x:a) (a1:my_array a) : Prop :=
  mem x (elts a1).

(* Why3 assumption *)
Definition array (a:Type) := my_array a.

Parameter max_array_length: Numbers.BinNums.Z.

Axiom non_neg_max_array_length : (0%Z < max_array_length)%Z.

(* Why3 assumption *)
Fixpoint map {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b} (f:a -> b)
  (l:Init.Datatypes.list a) {struct l}: Init.Datatypes.list b :=
  match l with
  | Init.Datatypes.nil => Init.Datatypes.nil
  | Init.Datatypes.cons x r => Init.Datatypes.cons (f x) (map f r)
  end.

(* Why3 assumption *)
Definition set1 (a:Type) := set.Fset.fset a.

(* Why3 assumption *)
Definition t (a:Type) := set.Fset.fset a.

(* Why3 assumption *)
Fixpoint elements {a:Type} {a_WT:WhyType a}
  (l:Init.Datatypes.list a) {struct l}: set.Fset.fset a :=
  match l with
  | Init.Datatypes.nil => set.Fset.empty : set.Fset.fset a
  | Init.Datatypes.cons x r => set.Fset.add x (elements r)
  end.

Axiom elements_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (l:Init.Datatypes.list a),
  list.Mem.mem x l <-> set.Fset.mem x (elements l).

Axiom t1 : forall (a:Type), Type.
Parameter t1_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (t1 a).
Existing Instance t1_WhyType.

Parameter view: forall {a:Type} {a_WT:WhyType a}, t1 a -> seq a.

Axiom t2 : forall (a:Type), Type.
Parameter t2_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (t2 a).
Existing Instance t2_WhyType.

Parameter view1: forall {a:Type} {a_WT:WhyType a}, t2 a -> seq a.

(* Why3 assumption *)
Definition t3 := BuiltIn.string.

Parameter compare1: BuiltIn.string -> BuiltIn.string -> Numbers.BinNums.Z.

Axiom compare_pre_order1 :
  is_pre_order
  (fun (y0:BuiltIn.string) (y1:BuiltIn.string) => compare1 y0 y1).

(* Why3 assumption *)
Definition t4 := Numbers.BinNums.Z.

Parameter compare2:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom compare_pre_order2 :
  is_pre_order
  (fun (y0:Numbers.BinNums.Z) (y1:Numbers.BinNums.Z) => compare2 y0 y1).

(* Why3 assumption *)
Inductive resource :=
  | resource'mk : Numbers.BinNums.Z -> Numbers.BinNums.Z ->
      Numbers.BinNums.Z -> Init.Datatypes.bool -> Numbers.BinNums.Z ->
      Numbers.BinNums.Z -> Init.Datatypes.bool -> resource.
Axiom resource_WhyType : WhyType resource.
Existing Instance resource_WhyType.

(* Why3 assumption *)
Definition isParameter (v:resource) : Init.Datatypes.bool :=
  match v with
  | resource'mk x x1 x2 x3 x4 x5 x6 => x6
  end.

(* Why3 assumption *)
Definition guardedBy (v:resource) : Numbers.BinNums.Z :=
  match v with
  | resource'mk x x1 x2 x3 x4 x5 x6 => x5
  end.

(* Why3 assumption *)
Definition whatIs (v:resource) : Numbers.BinNums.Z :=
  match v with
  | resource'mk x x1 x2 x3 x4 x5 x6 => x4
  end.

(* Why3 assumption *)
Definition nature (v:resource) : Init.Datatypes.bool :=
  match v with
  | resource'mk x x1 x2 x3 x4 x5 x6 => x3
  end.

(* Why3 assumption *)
Definition vis (v:resource) : Numbers.BinNums.Z :=
  match v with
  | resource'mk x x1 x2 x3 x4 x5 x6 => x2
  end.

(* Why3 assumption *)
Definition ty (v:resource) : Numbers.BinNums.Z :=
  match v with
  | resource'mk x x1 x2 x3 x4 x5 x6 => x1
  end.

(* Why3 assumption *)
Definition position (v:resource) : Numbers.BinNums.Z :=
  match v with
  | resource'mk x x1 x2 x3 x4 x5 x6 => x
  end.

(* Why3 assumption *)
Inductive resourceAccess :=
  | resourceAccess'mk : Numbers.BinNums.Z -> Numbers.BinNums.Z ->
      Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z ->
      resourceAccess.
Axiom resourceAccess_WhyType : WhyType resourceAccess.
Existing Instance resourceAccess_WhyType.

(* Why3 assumption *)
Definition lastWrite (v:resourceAccess) : Numbers.BinNums.Z :=
  match v with
  | resourceAccess'mk x x1 x2 x3 x4 => x4
  end.

(* Why3 assumption *)
Definition firstWrite (v:resourceAccess) : Numbers.BinNums.Z :=
  match v with
  | resourceAccess'mk x x1 x2 x3 x4 => x3
  end.

(* Why3 assumption *)
Definition lastRead (v:resourceAccess) : Numbers.BinNums.Z :=
  match v with
  | resourceAccess'mk x x1 x2 x3 x4 => x2
  end.

(* Why3 assumption *)
Definition firstRead (v:resourceAccess) : Numbers.BinNums.Z :=
  match v with
  | resourceAccess'mk x x1 x2 x3 x4 => x1
  end.

(* Why3 assumption *)
Definition first (v:resourceAccess) : Numbers.BinNums.Z :=
  match v with
  | resourceAccess'mk x x1 x2 x3 x4 => x
  end.

(* Why3 assumption *)
Fixpoint of_list {a:Type} {a_WT:WhyType a}
  (l:Init.Datatypes.list a) {struct l}: seq a :=
  match l with
  | Init.Datatypes.nil => empty : seq a
  | Init.Datatypes.cons x r => cons x (of_list r)
  end.

Axiom length_of_list :
  forall {a:Type} {a_WT:WhyType a},
  forall (l:Init.Datatypes.list a),
  ((length (of_list l)) = (list.Length.length l)).

(* Why3 assumption *)
Definition point_wise {a:Type} {a_WT:WhyType a} (s:seq a)
    (l:Init.Datatypes.list a) : Prop :=
  forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (list.Length.length l))%Z ->
  ((Init.Datatypes.Some (get s i)) = (list.Nth.nth i l)).

Axiom elts_seq_of_list :
  forall {a:Type} {a_WT:WhyType a},
  forall (l:Init.Datatypes.list a), point_wise (of_list l) l.

Axiom is_of_list :
  forall {a:Type} {a_WT:WhyType a},
  forall (l:Init.Datatypes.list a) (s:seq a),
  ((list.Length.length l) = (length s)) -> point_wise s l ->
  infix_eqeq s (of_list l).

Axiom of_list_app :
  forall {a:Type} {a_WT:WhyType a},
  forall (l1:Init.Datatypes.list a) (l2:Init.Datatypes.list a),
  infix_eqeq (of_list (Init.Datatypes.app l1 l2))
  (infix_plpl (of_list l1) (of_list l2)).

Axiom of_list_app_length :
  forall {a:Type} {a_WT:WhyType a},
  forall (l1:Init.Datatypes.list a) (l2:Init.Datatypes.list a),
  ((length (of_list (Init.Datatypes.app l1 l2))) =
   ((list.Length.length l1) + (list.Length.length l2))%Z).

Axiom of_list_snoc :
  forall {a:Type} {a_WT:WhyType a},
  forall (l:Init.Datatypes.list a) (x:a),
  infix_eqeq
  (of_list (Init.Datatypes.app l (Init.Datatypes.cons x Init.Datatypes.nil)))
  (snoc (of_list l) x).

Parameter to_list:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Init.Datatypes.list a.

Axiom to_list_empty :
  forall {a:Type} {a_WT:WhyType a},
  ((to_list (empty : seq a)) = Init.Datatypes.nil).

Axiom to_list_cons :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a), (0%Z < (length s))%Z ->
  ((to_list s) =
   (Init.Datatypes.cons (get s 0%Z) (to_list (mixfix_lb_dtdtrb s 1%Z)))).

Axiom to_list_length :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a), ((list.Length.length (to_list s)) = (length s)).

Axiom to_list_nth :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length s))%Z ->
  ((list.Nth.nth i (to_list s)) = (Init.Datatypes.Some (get s i))).

Axiom to_list_def_cons :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a),
  ((to_list (cons x s)) = (Init.Datatypes.cons x (to_list s))).

Axiom convolution_to_of_list :
  forall {a:Type} {a_WT:WhyType a},
  forall (l:Init.Datatypes.list a), ((to_list (of_list l)) = l).

Axiom compare_pre_order3 :
  is_pre_order
  (fun (y0:Numbers.BinNums.Z) (y1:Numbers.BinNums.Z) => compare2 y0 y1).

(* Why3 assumption *)
Definition key := Numbers.BinNums.Z.

Axiom t5 : forall (a:Type), Type.
Parameter t5_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (t5 a).
Existing Instance t5_WhyType.

Parameter dom:
  forall {a:Type} {a_WT:WhyType a}, t5 a -> set.Fset.fset Numbers.BinNums.Z.

Parameter view2:
  forall {a:Type} {a_WT:WhyType a}, t5 a -> Numbers.BinNums.Z -> a.

Parameter empty1: forall {a:Type} {a_WT:WhyType a}, t5 a.

Axiom empty'def1 :
  forall {a:Type} {a_WT:WhyType a},
  ((dom (empty1 : t5 a)) =
   (set.Fset.empty : set.Fset.fset Numbers.BinNums.Z)).

Parameter mem2:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z -> t5 a ->
  Init.Datatypes.bool.

Axiom mem'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (k:Numbers.BinNums.Z) (s:t5 a),
  ((mem2 k s) = Init.Datatypes.true) <-> set.Fset.mem k (dom s).

Parameter find_opt:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z -> t5 a ->
  Init.Datatypes.option a.

Axiom find_opt'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:Numbers.BinNums.Z) (m:t5 a),
  match find_opt x m with
  | Init.Datatypes.None => ~ set.Fset.mem x (dom m)
  | Init.Datatypes.Some r => set.Fset.mem x (dom m) /\ (r = (view2 m x))
  end.

Axiom compare_pre_order4 :
  is_pre_order
  (fun (y0:BuiltIn.string) (y1:BuiltIn.string) => compare1 y0 y1).

(* Why3 assumption *)
Definition key1 := BuiltIn.string.

Axiom t6 : forall (a:Type), Type.
Parameter t6_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (t6 a).
Existing Instance t6_WhyType.

Parameter dom1:
  forall {a:Type} {a_WT:WhyType a}, t6 a -> set.Fset.fset BuiltIn.string.

Parameter view3:
  forall {a:Type} {a_WT:WhyType a}, t6 a -> BuiltIn.string -> a.

Parameter empty2: forall {a:Type} {a_WT:WhyType a}, t6 a.

Axiom empty'def2 :
  forall {a:Type} {a_WT:WhyType a},
  ((dom1 (empty2 : t6 a)) = (set.Fset.empty : set.Fset.fset BuiltIn.string)).

Parameter mem3:
  forall {a:Type} {a_WT:WhyType a}, BuiltIn.string -> t6 a ->
  Init.Datatypes.bool.

Axiom mem'spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (k:BuiltIn.string) (s:t6 a),
  ((mem3 k s) = Init.Datatypes.true) <-> set.Fset.mem k (dom1 s).

Parameter find_opt1:
  forall {a:Type} {a_WT:WhyType a}, BuiltIn.string -> t6 a ->
  Init.Datatypes.option a.

Axiom find_opt'spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:BuiltIn.string) (m:t6 a),
  match find_opt1 x m with
  | Init.Datatypes.None => ~ set.Fset.mem x (dom1 m)
  | Init.Datatypes.Some r => set.Fset.mem x (dom1 m) /\ (r = (view3 m x))
  end.

(* Why3 goal *)
Theorem sndResource'vc :
  forall (resourceMap:t5 resource),
  forall (bindings:Init.Datatypes.list (Numbers.BinNums.Z* resource)%type),
  ~ ((forall (a:resource) (b:Numbers.BinNums.Z),
      (a = (view2 resourceMap b)) /\ set.Fset.mem b (dom resourceMap) <->
      list.Mem.mem (b, a) bindings) /\
     (forall (a:Numbers.BinNums.Z), set.Fset.mem a (dom resourceMap) ->
      (exists p:(Numbers.BinNums.Z* resource)%type,
       list.Mem.mem p bindings /\ (match p with
                                   | (r, _) => r
                                   end = a))) /\
     (forall (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
      (0%Z <= i)%Z /\ (i < (list.Length.length bindings))%Z ->
      (0%Z <= j)%Z /\ (j < (list.Length.length bindings))%Z -> ~ (i = j) ->
      ~ ((list.Nth.nth i bindings) = (list.Nth.nth j bindings)))).
Proof.
intros resourceMap bindings.

Qed.

